# Copyright 2025 Open Source Robotics Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file was generated by Gemini 2.5 Pro.

"""
Generates a Markdown list and/or an avatar collage of contributors.
"""

import json
import argparse
from collections import Counter
from github_api import build_graphql_query, fetch_contributors_gh_cli
from collage import download_avatar, create_collage

def generate_md(args):
    """Generates a Markdown file of contributors from a JSON file."""
    try:
        with open(args.input_json, 'r', encoding='utf-8') as f:
            pull_requests = json.load(f)
    except (IOError, json.JSONDecodeError) as e:
        print(f"❌ Error reading or parsing '{args.input_json}': {e}")
        return

    if not pull_requests:
        print("No pull requests found in the input file.")
        return
        
    author_counts = Counter(pr['author'] for pr in pull_requests if 'author' in pr)
    
    if not author_counts:
        print("No authors found in the input file.")
        return
        
    unique_authors = sorted(list(author_counts.keys()))
    print(f"Found {len(unique_authors)} unique contributors. Building GraphQL query...")

    graphql_query = build_graphql_query(unique_authors)
    all_user_data = fetch_contributors_gh_cli(graphql_query)

    if not all_user_data:
        print("❌ Failed to fetch contributor data. Aborting.")
        return

    contributors_md = ["# Contributors\n"]
    
    sorted_contributors = sorted(
        filter(None, all_user_data.values()),
        key=lambda u: (u.get('name') or u.get('login', '')).lower()
    )

    for user_data in sorted_contributors:
        display_name = user_data.get('name') or user_data.get('login')
        username = user_data.get('login', 'unknown')
        profile_url = user_data.get('url', '#')
        pr_count = author_counts.get(username, 0)
        pr_plural = "PR" if pr_count == 1 else "PRs"

        md_line = f"1. {display_name} ([@{username}]({profile_url})) - {pr_count} {pr_plural}"
        contributors_md.append(md_line)

    try:
        with open(args.output_md, 'w', encoding='utf-8') as f:
            f.write("\n".join(contributors_md) + "\n")
        print(f"\n✅ Successfully wrote contributors list to '{args.output_md}'")
    except IOError as e:
        print(f"❌ Error writing to '{args.output_md}': {e}")

def generate_collage(args):
    """Generates a collage of avatars."""
    if args.input_json:
        try:
            with open(args.input_json, 'r', encoding='utf-8') as f:
                pull_requests = json.load(f)
            usernames = sorted(list(set(pr['author'] for pr in pull_requests if 'author' in pr)))
        except (IOError, json.JSONDecodeError) as e:
            print(f"❌ Error reading or parsing '{args.input_json}': {e}")
            return
    else:
        usernames = args.usernames

    if not usernames:
        print("No usernames provided.")
        return

    graphql_query = build_graphql_query(usernames)
    all_user_data = fetch_contributors_gh_cli(graphql_query)

    if not all_user_data:
        print("❌ Failed to fetch user data. Aborting.")
        return

    avatar_paths = []
    for user_data in all_user_data.values():
        if user_data:
            username = user_data.get('login')
            avatar_url = user_data.get('avatarUrl')
            if username and avatar_url:
                avatar_path = download_avatar(username, avatar_url)
                if avatar_path:
                    avatar_paths.append(avatar_path)

    if avatar_paths:
        create_collage(
            avatar_paths,
            args.output_png,
            rows=args.rows,
            columns=args.columns
        )
    else:
        print("No avatars were downloaded. Collage not created.")

def main():
    """Main function to parse arguments and generate the contributors list."""
    parser = argparse.ArgumentParser(
        description="Generates a Markdown list and/or an avatar collage of contributors."
    )
    subparsers = parser.add_subparsers(dest="command", required=True)

    # --- 'md' Sub-command ---
    parser_md = subparsers.add_parser("md", help="Generate a Markdown file of contributors from a JSON file.")
    parser_md.add_argument("input_json", help="Path to the input JSON file.")
    parser_md.add_argument("output_md", help="Path for the output Markdown file.")
    parser_md.set_defaults(func=generate_md)

    # --- 'collage' Sub-command ---
    parser_collage = subparsers.add_parser("collage", help="Generate a collage of avatars.")
    input_group = parser_collage.add_mutually_exclusive_group(required=True)
    input_group.add_argument("--input-json", help="Path to the input JSON file.")
    input_group.add_argument("--usernames", nargs='+', help="A list of GitHub usernames.")
    parser_collage.add_argument("output_png", help="Path to save the generated avatar collage.")
    collage_group = parser_collage.add_mutually_exclusive_group()
    collage_group.add_argument(
        "--rows",
        type=int,
        help="Number of rows for the avatar collage. Cannot be used with --columns."
    )
    collage_group.add_argument(
        "--columns",
        type=int,
        help="Number of columns for the avatar collage. Cannot be used with --rows."
    )
    parser_collage.set_defaults(func=generate_collage)

    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()