# Pull Request Build Workflow

This document explains the end-to-end continuous integration (CI) process, from the moment a pull request (PR) is created in a Gazebo library repository to the execution of build and test jobs on Linux, macOS, and Windows.

We will use a pull request for `gz-math` within the **Jetty** collection as our running example.

## 1. The Trigger: From GitHub to Jenkins

The process begins when a developer opens a pull request on a Gazebo repository, such as `gazebosim/gz-math`.

- **GitHub App/Webhook:** A GitHub Application or a webhook is installed on the `gazebosim` organization. When a PR is opened or updated, GitHub sends a notification payload to the Jenkins server.
- **Jenkins PR Scanner:** The Jenkins server listens for these notifications via the "GitHub Pull Request Builder" (ghprb) plugin, which scans for incoming PRs and matches them to the appropriate pre-generated jobs.

## 2. Job Definition: The Jenkins DSL Blueprint

The multitude of Jenkins jobs for every library, collection, and platform are not configured manually. They are generated programmatically using Jenkins Job DSL, which is a feature that allows you to define jobs in code.

- **`gazebo_libs.dsl`**: The heart of the job generation is the Groovy script [jenkins-scripts/dsl/gazebo_libs.dsl](../jenkins-scripts/dsl/gazebo_libs.dsl). This script runs as part of a "seed" job in Jenkins and is responsible for creating all the other CI jobs.
- **`gz-collections.yaml`**: The DSL script is powered by a single source of truth: [jenkins-scripts/dsl/gz-collections.yaml](../jenkins-scripts/dsl/gz-collections.yaml). This YAML file defines the entire Gazebo ecosystem for the CI system, including all collections, the libraries within them, their major versions, and their corresponding branches.

For our `gz-math` example in the `jetty` collection, the YAML looks like this:
```yaml
- name: 'jetty'
  libs:
    - name: gz-math
      major_version: 9
      repo:
        current_branch: gz-math9
    # ... other libraries
  ci:
    configs:
      - noble
      - brew_amd64
      - brew_arm64
      - win_conda_noble
```
The DSL script parses this file and generates a job for each library and CI configuration combination. For our example, the generated PR jobs would be named:

- `gz_math-ci-pr_any-noble-amd64` (for Linux)
- `gz_math-ci-pr_any-homebrew-amd64` (for macOS)
- `gz_math-ci-pr_any-homebrew-arm64` (for macOS)
- `gz_math-pr-cnlwin` (for Windows)

## 3. Job Matching: Linking a PR to a Job

A critical part of the process is ensuring a pull request for a specific library branch only triggers the correct set of jobs. This matching logic is explicitly coded in DSL helper scripts.

- **`*GitHub.groovy` Helper Scripts:** The logic is contained in files within `jenkins-scripts/dsl/_configs_/`, particularly [GenericAnyJobGitHub.groovy](../jenkins-scripts/dsl/_configs_/GenericAnyJobGitHub.groovy). These scripts configure the "GitHub Pull Request Builder" (ghprb) plugin for each job generated by the DSL.

- **The `whiteListTargetBranches` Logic:** The [GenericAnyJobGitHub.groovy](../jenkins-scripts/dsl/_configs_/GenericAnyJobGitHub.groovy) script contains the precise matching logic:
  ```groovy
  // In GenericAnyJobGitHub.groovy
  ...
  whiteListTargetBranches {
    supported_branches.each { supported_branch ->
      'org.jenkinsci.plugins.ghprb.GhprbBranch' {
        branch supported_branch
      }
    }
  }
  ...
  ```
  This code configures the ghprb trigger to only activate for PRs targeting specific branches.

### The End-to-End Matching Flow

1.  **Blueprint:** [`gazebo_libs.dsl`](../jenkins-scripts/dsl/gazebo_libs.dsl) reads [`gz-collections.yaml`](../jenkins-scripts/dsl/gz-collections.yaml) and sees that `gz-math` in the `jetty` collection uses the branch `gz-math9`.
2.  **Job Generation:** The DSL script generates the CI jobs (e.g., `gz_math-ci-pr_any-noble-amd64`). When doing so, it calls the helper scripts and passes `gz-math9` as a `supported_branch`.
3.  **Job Configuration:** The [`GenericAnyJobGitHub.groovy`](../jenkins-scripts/dsl/_configs_/GenericAnyJobGitHub.groovy) script configures the Jenkins job, adding `gz-math9` to its "White-listed target branches".
4.  **The Match:** When a developer opens a PR targeting the `gz-math9` branch, the ghprb plugin sees that the PR's target branch is in the job's whitelist, and **a match is made**, triggering the build. A PR targeting any other branch would be ignored by this job.

## 4. Dependency Resolution: A Platform-Specific Deep Dive

Once the correct job is triggered, it begins executing. This is where dependencies are installed, a process that is unique to each platform.

### Linux: Dependencies Pre-installed in a Dynamic Dockerfile

The Linux strategy prioritizes speed by pre-installing all required `.deb` packages into a Docker image that is generated on-the-fly at the beginning of the build job.

1.  **Script Chain:** The process follows a chain of scripts: [gz_math-compilation.bash](../jenkins-scripts/docker/lib/gz_math-compilation.bash) -> [generic-building-base.bash](../jenkins-scripts/docker/lib/generic-building-base.bash) -> [docker_generate_dockerfile.bash](../jenkins-scripts/docker/lib/docker_generate_dockerfile.bash).
2.  **Dependency Aggregation:** The scripts collect dependency names from multiple sources into a master list (`$PACKAGES_CACHE_AND_CHECK_UPDATES`):
    - **`packages.apt` files**: The build can also find `packages.apt` or `packages-<distro>.apt` files in the library's source code to include other required packages.
    - **`BASE_DEPENDENCIES`**: A common list of packages needed for all builds.
3.  **Dockerfile Generation:** The [docker_generate_dockerfile.bash](../jenkins-scripts/docker/lib/docker_generate_dockerfile.bash) script writes a new `Dockerfile`, injecting the master package list into an `apt-get install` command.
4.  **`build.sh` Generation:** The [_generic_linux_compilation_build.sh.bash](../jenkins-scripts/docker/lib/_generic_linux_compilation_build.sh.bash) script writes a new `build.sh`, which is executed inside the docker container.
5.  **Build Execution:** The job builds this Docker image and runs the compilation inside the container, where all dependencies are already present.

Note that both the generated files `Dockerfile` and `build.sh` are stored as Jenkins artifacts and can be viewed on the jobs page (e.g. [gz_math-ci-pr_any-noble-amd64](https://build.osrfoundation.org/job/gz_math-ci-pr_any-noble-amd64/lastBuild/)).

### Windows: Building Dependencies from Source

The Windows strategy is a hybrid: it uses the `pixi` package manager and `conda-forge` packages for a baseline of third-party tools and then builds all Gazebo dependencies from source using `gazebodistro`. The process is orchestrated by [jenkins-scripts/lib/colcon-default-devel-windows.bat](../jenkins-scripts/lib/colcon-default-devel-windows.bat).

1.  **Baseline via `pixi`/`conda`:** A `pixi` environment is created to install large, pre-built binary packages like Boost, OGRE, Qt, etc.
2.  **Determine Target Version:** The script runs [tools/detect_cmake_major_version.py](../jenkins-scripts/tools/detect_cmake_major_version.py) on the PR's `CMakeLists.txt` to find the library's major version (e.g., `9`).
3.  **Checkout Dependencies from `gazebodistro`:** A helper function uses `vcs import` to read the appropriate `.yaml` file from the `gazebodistro` repository (e.g., `gz-math9.yaml`). `vcs` then clones the source code for **all listed dependencies** into the local workspace.
4.  **Build Workspace:** The `colcon build` command is used to compile the entire workspace from source.

### macOS: Pre-built Homebrew Packages ("Bottles")

The macOS strategy relies on the Homebrew package manager, preferring its pre-compiled binaries ("bottles"). This is orchestrated by [jenkins-scripts/lib/project-default-devel-homebrew-amd64.bash](../jenkins-scripts/lib/project-default-devel-homebrew-amd64.bash).

1.  **Determine Formula Name:** The script uses [`detect_cmake_major_version.py`](../jenkins-scripts/tools/detect_cmake_major_version.py) to determine the correct Homebrew formula name (e.g., `gz-math9`).
2.  **Install Dependencies via Homebrew:** The script ensures the `osrf/simulation` Homebrew tap is active and then runs the central command:
    ```bash
    brew install gz-math9 --only-dependencies
    ```
    Homebrew reads the `depends_on` section of the `gz-math9` formula and installs each dependency, downloading pre-compiled bottles whenever possible and falling back to a source build if a bottle is unavailable. `gazebodistro` is not used.
